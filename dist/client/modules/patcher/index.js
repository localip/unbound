"use strict";var a;Object.defineProperty(exports,"__esModule",{value:!0}),!function _export(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(exports,{Type:()=>a,create:()=>create,before:()=>before,instead:()=>instead,after:()=>after,unpatchAll:()=>unpatchAll,patches:()=>c,default:()=>e});const b=require("../../../common/logger");require("./menu"),function(a){a.Before="before",a.Instead="instead",a.After="after"}(a||(a={}));const c=[],d=(0,b.createLogger)("Patcher");function getPatchesByCaller(a){if(!a)return[];let b=[];for(let d of c){let e=[...d.patches.before,...d.patches.instead,...d.patches.after];for(let f of e)f.caller===a&&b.push(f)}return b}function unpatchAll(a){let b=getPatchesByCaller(a);if(b.length)for(let c of b)c.unpatch()}function patch(b,e,f,g,h=a.After,i=!1){if(b&&"string"==typeof b){if(e&&["function","object"].includes(typeof e)){if(f&&"string"==typeof f){if(g&&"function"==typeof g){if(h&&"string"==typeof h&&["after","before","instead"].includes(h)){if(void 0===e[f])throw ReferenceError(`function ${f} does not exist on the second argument (object or function)`)}else throw TypeError('fifth argument "type" must be of type string and any of the three: after, before, instead')}else throw TypeError('fourth argument "callback" must be of type function')}else throw TypeError('third argument "func" must be of type string')}else throw TypeError('second argument "mdl" must be of type function or object')}else throw TypeError('first argument "caller" must be of type string');let j=function get(a,b){let e=c.find(c=>c.mdl===a&&c.func===b);return e||function push(a,b){var e;let f={mdl:a,func:b,original:a[b],unpatch(){f.mdl[f.func]=f.original,f.patches={before:[],after:[],instead:[]}},patches:{before:[],after:[],instead:[]}},g=(e=f,function(){if(!e?.patches?.before.length&&!e?.patches?.after.length&&!e?.patches?.instead.length&&!c.find(a=>a.mdl===e.mdl&&a.func===e.func))return e.unpatch(),new.target?new e.original(...arguments):e.original.apply(this,arguments);let a,b=arguments,f=e.patches.before;for(let g=0;g<f.length;g++){let h=f[g];if(h)try{let i=h.callback(this,b,e.original.bind(this));Array.isArray(i)&&(b=i),h.once&&h.unpatch()}catch(j){d.error(`Could not fire before patch for ${e.func} of ${h.caller}`,j)}}let k=e.patches.instead;if(k.length)for(let l=0;l<k.length;l++){let m=k[l];if(m)try{let n=m.callback(this,b,e.original.bind(this));void 0!==n&&(a=n),m.once&&m.unpatch()}catch(o){d.error(`Could not fire instead patch for ${e.func} of ${m.caller}`,o)}}else a=new.target?new e.original(...b):e.original.apply(this,b);let p=e.patches.after;for(let q=0;q<p.length;q++){let r=p[q];if(r)try{let s=r.callback(this,b,a,b=>a=b);void 0!==s&&(a=s),r.once&&r.unpatch()}catch(t){d.error(`Could not fire after patch for ${e.func} of ${r.caller}`,t)}}return a});a[b]=g;let h=Object.getOwnPropertyDescriptors(f.original);return delete h.length,Object.defineProperties(a[b],{...h,toString:{value:()=>f.original.toString(),configurable:!0,enumerable:!1},__original:{value:f.original,configurable:!0,enumerable:!1}}),c.push(f),f}(a,b)}(e,f),k={caller:b,once:i,type:h,id:j.patches?.[h]?.length??0,callback:g,unpatch(){let a=j.patches?.[h].findIndex(a=>a.id===k.id);if(~a&&j.patches?.[h].splice(a,1),j.patches?.before.length||j.patches?.after.length||j.patches?.instead.length)return;let b=c.findIndex(a=>a.mdl==e&&a.func==f);b&&(c[b]?.unpatch(),c.splice(b,1))}};return j.patches[h]??=[],j.patches[h].push(k),k.unpatch}function before(b,c,d,e,f=!1){return patch(b,c,d,e,a.Before,f)}function instead(b,c,d,e,f=!1){return patch(b,c,d,e,a.Instead,f)}function after(b,c,d,e,f=!1){return patch(b,c,d,e,a.After,f)}function create(a){return{getPatchesByCaller,before:(b,c,d,e=!1)=>before(a,b,c,d,e),instead:(b,c,d,e=!1)=>instead(a,b,c,d,e),after:(b,c,d,e=!1)=>after(a,b,c,d,e),unpatchAll:()=>unpatchAll(a)}}const e={create,before,instead,after,unpatchAll,patches:c}